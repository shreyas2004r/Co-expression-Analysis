# -*- coding: utf-8 -*-
"""BS1009_PlantsProject_Group 7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rIT83qvmfyffBrFxG7VgRlzRTo-2_Ur3
"""

#Mount Google Drive
from google.colab import drive
drive.mount('/content/gdrive')

genes_of_interest_unfiltered = []
#Reading genes txt file
with open('/content/gdrive/MyDrive/Job5800.results.txt', 'r') as genes:
  genes_lines = genes.readlines()
photo_genes = ''

#Separating out photosynthesis-related genes
for line in genes_lines:
  if 'Photosynthesis' in line and 'cd' in line:
    genes = line.strip().split('\t')
    photo_genes = genes[2].replace("'",'')
  if photo_genes not in genes_of_interest_unfiltered:
    genes_of_interest_unfiltered.append(photo_genes)

genes_of_interest = list(filter(None, genes_of_interest_unfiltered)) #Removing empty elements
print(genes_of_interest)
print(len(genes_of_interest))

id_to_exp = {}
with open('/content/gdrive/MyDrive/taxid3708_all_expmat.tsv','r') as matrix:
  unfilt_matrix = matrix.readlines()

for i in range(len(unfilt_matrix)):
  gene_id = unfilt_matrix[i].lower().split('\t')
  if gene_id[0] in genes_of_interest:
    gene_exp_values = gene_id[1:]
    gene_exp_values = [float(gene) for gene in gene_exp_values]
    id_to_exp[gene_id[0]] = gene_exp_values
print(len(id_to_exp))

from scipy import stats #imports the stats module that contains many statistical methods

#Example 1.
r, p = stats.pearsonr([1, 2, 3, 4, 5], [10, 20, 30, 40, 50]) #two expression vectors are perfectly correlated
print('The first r-value is ', r)

#Example 2.
r, p = stats.pearsonr([1, 2, 3, 4, 5], [10, 50, 20, 40, 30]) #two exoression vectors are poorly correlated
print('The second r-value is ', r)

#Example 2.
r, p = stats.pearsonr([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) #twi exoression vectors are perfectly anti-correlated
print('The third r-value is ', r)

from scipy import stats

network = []
gene_keys = list(id_to_exp.keys())

for i in range(len(gene_keys)):
  x = id_to_exp[gene_keys[i]]
  for j in range(i+1, len(gene_keys)):
    y = id_to_exp[gene_keys[j]]
    r, p = stats.pearsonr(x, y)
    if r>0.9925:
      network.append([gene_keys[i], gene_keys[j]])
print(network)
print(len(network))

import IPython
from IPython.display import display, HTML

def style_one_node(GeneID, shape, color):
  '''Returns the string of html css style sheet to be added to the index html file'''
  node_styling='''\
              {
              selector: 'node[id="GENEID"]',
              style: {
                  shape: 'ENTER_SHAPE',
                  'background-color': 'ENTER_COLOR',
                  }
              },
  '''
  node_styling = node_styling.replace('GENEID', GeneID)
  node_styling = node_styling.replace('ENTER_SHAPE', shape)
  node_styling = node_styling.replace('ENTER_COLOR', color)

  return node_styling

def generate_html_index(list_of_edges):
  '''Returns a string of a html with javascript code to render the network from list_of_nodes and list_of_edges. list_of_nodes = ['a','b','c'], list_of_edges = [['a','b'],['b','c']]'''
  front_html = '''\
  <!doctype html>
  <html>
    <head>
        <title>Network on Cytoscape</title>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.9.4/cytoscape.min.js'></script>
    </head>

    <style>
        #cy {
            width: 1000px;
            height: 950px;
            }
    </style>

    <body style="background-color:rgb(194, 229, 243);">
      <div><p>Click to download as: <br><a id="pngimage" href="#" download="NetworkImage.png">Image</a> | <a id="cyjson" href="#" download="NetworkImage.json">JSON</a></p></div>
      <div id="cy"></div>
      <script>
        var cy = cytoscape({
          container: document.getElementById('cy'),
  '''


  mid_html = '''\
          elements: {
              nodes: [\n
  '''

  list_of_nodes = []
  for i in list_of_edges:
      list_of_nodes +=i
  list_of_nodes = list(set(list_of_nodes))

  #get nodes
  # { data: { id: 'a', node_type: 'q/t', color: 'x', shape: 'z' } },
  for j in list_of_nodes:
      shape, color = "triangle", "Silver"
      ntype = "linked"
      new_node = "\t"*5 + "{\n" + "\t"*6 + "data: {\n" +\
        "\t"*6 + "id: \'" + j + "\',\n" +\
        "\t"*6 + "node_type: \'" + ntype + "\',\n" +\
        "\t"*6 + "color: \'" + color + "\',\n" +\
        "\t"*6 + "shape: \'" + shape + "\'\n" + "\t"*6 + "}\n" + "\t"*5 + "}"
      if list_of_nodes.index(j) != len(list_of_nodes)-1:
        new_node += ",\n"
      else:
        new_node += "\n\t\t\t\t],\n"
      mid_html += new_node

  mid2_html = '''\
              edges: [\n
  '''
  mid_html += mid2_html
  #get edges
  for i in range(len(list_of_edges)):
    ID = list_of_edges[i][0] + " | " + list_of_edges[i][1]
    source = list_of_edges[i][0]
    target = list_of_edges[i][1]
    new_edge = "\t"*5 + "{\n" + "\t"*6 + "data: {\n" +\
      "\t"*7 + "id: \'" + ID + "\',\n" +\
      "\t"*7 + "source: \'" + source + "\',\n" +\
      "\t"*7 + "target: \'" + target + "\'\n" + "\t"*6 + "}\n" + "\t"*5 + "}"
    if i != (len(list_of_edges)-1):
      new_edge += ",\n"
    else:
      new_edge = new_edge + "\n\t\t\t\t]\n"
    mid_html += new_edge

  back_html = '''\
            },
            style: [
              {
              selector: "node",
              style: {
                  shape: 'data(shape)',
                  'height': '3px',
                  'width': '3px',
                  'background-color': 'data(color)',
                  label: 'data(id)',
                  'border-style':'solid',
                  'border-color':'black',
                  'border-width':'0.1px',
                  'font-size': 1.2,
                  'text-margin-y':'-0.4px',
                  'text-outline-color':'white',
                  'text-outline-width':'0.15px',
                  'text-outline-opacity':0.8
                  }
              },
              {
              selector: 'edge',
              style: {
                  'width': '0.1px',
                  'line-style':'solid',
                  'line-fill':'solid',
                  'background-color': '#F5F5F5',
                  'opacity':0.4
                  }
              },
              {
              selector:'core',
              style: {
                  'outside-texture-bg-color':'white',
                  'outside-texture-bg-opacity':1
                  }
              },
            ],
            layout: {
              name: 'cose',
              animateThreshold: 1,
              nodeOverlap: 100,
              gravity: 400,
              componentSpacing: 100,
              edgeElasticity: 100,
              minTemp: 1,
              initialTemp: 1000,
              stop: function() {
                  //generate PNG image to display from "id = pngimage"
                  var png64 = cy.png({bg:'white'});
                  document.getElementById('pngimage').setAttribute('href', png64);
                  //generate JSON to download for id = cyjson
                  var jsonc = JSON.stringify(cy.json(), null, "\\t");
                  document.getElementById('cyjson').setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(jsonc));
              }
            }
        });

      </script>
    </body>
  </html>
  '''

  index_html = front_html + mid_html + back_html
  return index_html

def save_index_file(index_html, guide_gene):
  '''Writes the html/js string into a html file and return the path to the new html file'''
  network_html_path = "Network_index_" + guide_gene + '.html'
  with open(network_html_path, 'w+') as index_file:
    index_file.write(index_html)
  print("HTML file saved in: " + network_html_path+ "\n")
  return network_html_path

##Run this cell to see an example of the network. Do not alter this code.
network_z = generate_html_index(network)
index_html = network_z.replace('NetworkImage', 'Genes') #Specify Name of png file to be downloaded based on guide gene
network_html_path = save_index_file(index_html, 'Genes')
IPython.display.HTML(filename = network_html_path)

gene_counts = {}

for gene_pair in network:
  for gene in gene_pair:
    if gene in gene_counts:
      gene_counts[gene] += 1
    else:
      gene_counts[gene] = 1

most_connected_gene = []
max_connection = 0
for gene, count in gene_counts.items():
  if count > max_connection:
    max_connection = count
    most_connected_gene = gene

print("Most connected gene: ", most_connected_gene)

#Mount Google Drive
from scipy import stats
from google.colab import drive
import os
drive.mount('/content/gdrive')

gene_to_anno = {}
#Reading mapman file
with open('/content/gdrive/MyDrive/Job5800.results.txt', 'r') as mapman:
  mapman_read = mapman.readlines()
genes_name = ''
genes_list_unf = []
gene_anno = ''
gene_anno_list_unf = []

#Creating list of gene names
for line in mapman_read:
  if 'cd' in line:
    genes = line.strip().split('\t')
    genes_name = genes[2].replace("'",'')
    genes_list_unf.append(genes_name)
genes_list = list(filter(None, genes_list_unf))

#Creating list of gene annotations
for line in mapman_read:
  if 'mercator4v6.0:' in line:
    desc_split = line.strip().split('\t')
    gene_anno = ''.join(desc_split).partition('mercator4v6.0: ')[2].partition(' &')[0]
    gene_anno_list_unf.append(gene_anno)
gene_anno_list = list(filter(None, gene_anno_list_unf))

#Creating dictionary
gene_to_anno = {genes_list[n] : gene_anno_list[n] for n in range(len(genes_list))}
print(len(gene_to_anno))

gene_of_interest = 'cdy71758' #the ID of the gene from week 10
from scipy.stats import pearsonr
gene_correlation = {}
gene_duplic = []
counts = 0

with open('/content/gdrive/MyDrive/taxid3708_all_expmat.tsv','r') as matrix_1:
  matrix = matrix_1.readlines()[1:]

for line in matrix:
  gene_1 = line.lower().split('\t')
  r , _ = stats.pearsonr(id_to_exp[gene_of_interest], [float(i) for i in gene_1[1:]])
  if r == r:
    gene_correlation[gene_1[0]] = r

def get_gene_corr(gene):
  return(gene_correlation[gene])

print('number', '\t', 'R',  '\t', 'Gene ID', '\t', 'Description')
for i in sorted(gene_correlation, key = get_gene_corr, reverse = True):
  if counts == 50:
    break
  elif gene_correlation[i] not in gene_duplic:
    print(str(counts + 1), '\t', str(gene_correlation[i]), '\t', i, '\t', gene_to_anno[i])
    counts += 1
    gene_duplic.append(gene_correlation[i])

import pandas as pd
import seaborn as sns

expression = [10,11,29,30,35,25, 100,110,130] #expression vector
organs = ['leaf','leaf','leaf','root','root','root','seed','seed','seed'] #annotation list

df = pd.DataFrame({'Expression':expression, 'Organs':organs}) #The data is entered into a dataframe (google what it is if you are interested)

g = sns.catplot(data=df, kind="bar", x="Organs", y="Expression", ci="sd") #the dataframe is used to plot barplots, using standard deviation to indicate confidence interval
g.set_xticklabels(rotation=90)

import pandas as pd
import seaborn as sns
gene_of_interest = 'cdy71758'

with open('/content/gdrive/MyDrive/taxid3708_all_expmat.tsv', 'r') as matrix_1:
  matrix = matrix_1.readlines()

#y-axis
keys = matrix[0]
keys_list = keys.split('\t')[1:]
print(keys_list)

value_list = []
dict = {}
for line in matrix:
  row = line.split('\t')
  if gene_of_interest in row[0].lower():
    for j in range(1, len(row)):
      value_list.append(float(row[j]))

for i in range(len(keys_list)):
  dict[keys_list[i]] = value_list[i]

with open('/content/gdrive/MyDrive/7_sample_annotation.csv', 'r') as stressmatrix:
  stress_matrix = stressmatrix.readlines()

gene_key = stress_matrix[26]
gene_value = str(stress_matrix[22])
stress_gene_dict = {}

for i in stress_matrix[1:]:
  line = i.split(',')
  stress_gene_dict[line[-5]] = line[-9]

expression, stressors = [], []
for i in dict:
  if i in stress_gene_dict:
    expression.append(dict[i])
    stressors.append(stress_gene_dict[i])
print(stressors) #x-axis

print(expression, stressors)

#Plug in your data into the seaborn
df = pd.DataFrame({'Expression':expression, 'Stressors':stressors}) #The data is entered into a dataframe (google what it is if you are interested)

g = sns.catplot(data=df, kind="bar", x="Stressors", y="Expression", ci="sd") #the dataframe is used to plot barplots, using standard deviation to indicate confidence interval
g.set_xticklabels(rotation=90)